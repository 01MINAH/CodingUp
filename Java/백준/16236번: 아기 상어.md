`# bfs`

```java
import java.io.*;
import java.util.*;

public class ì•„ê¸°ìƒì–´16236 {

    // ë§µ í¬ê¸° ë° ìƒì–´ ìƒíƒœ ê´€ë ¨ ë³€ìˆ˜
    static int N;               // ë§µì˜ í¬ê¸°
    static int sy, sx;          // ìƒì–´ì˜ í˜„ì¬ ìœ„ì¹˜
    static int sSize = 2;       // ìƒì–´ í¬ê¸° (ì´ˆê¸° í¬ê¸°: 2)
    static int sEatCnt = 0;     // í˜„ì¬ í¬ê¸°ì—ì„œ ë¨¹ì€ ë¬¼ê³ ê¸° ìˆ˜
    static int ans = 0;         // ì´ ì´ë™ ì‹œê°„ â±ï¸

    static int[][] map;         // ë§µ ì •ë³´
    static boolean[][] visit;   // ë°©ë¬¸ ì—¬ë¶€ ì²´í¬
    static Queue<Node> queue = new ArrayDeque<>(); // BFS íƒìƒ‰ìš© í

    // ìƒí•˜ì¢Œìš° ë°©í–¥ (â†‘ â†“ â† â†’)
    static int[] dy = { -1, 1, 0, 0 };
    static int[] dx = {  0, 0,-1, 1 };

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());

        map = new int[N][N];
        visit = new boolean[N][N];

        // ë§µ ì…ë ¥ + ìƒì–´ ì‹œì‘ ìœ„ì¹˜ ì°¾ê¸° ğŸ¦ˆ
        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            for (int j = 0; j < N; j++) {
                int val = Integer.parseInt(st.nextToken());
                map[i][j] = val;

                if (val == 9) {
                    sy = i;
                    sx = j;
                }
            }
        }

        // ë” ì´ìƒ ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ê°€ ì—†ì„ ë•Œê¹Œì§€ ë°˜ë³µ
        while (true) {
            int dist = bfs(); // ê°€ì¥ ê°€ê¹Œìš´ ë¬¼ê³ ê¸°ê¹Œì§€ ê±°ë¦¬
            if (dist == 0) break; // ë” ì´ìƒ ì—†ìœ¼ë©´ ì¢…ë£Œ
            ans += dist; // ì´ë™ ì‹œê°„ ëˆ„ì 
        }

        System.out.println(ans); // ê²°ê³¼ ì¶œë ¥
    }

    // BFSë¡œ ë¨¹ì„ ìˆ˜ ìˆëŠ” ê°€ì¥ ê°€ê¹Œìš´ ë¬¼ê³ ê¸° íƒìƒ‰
    static int bfs() {
        int minY = Integer.MAX_VALUE;
        int minX = Integer.MAX_VALUE;
        int minDis = Integer.MAX_VALUE;

        // ë°©ë¬¸ ë°°ì—´ ì´ˆê¸°í™”
        for (int i = 0; i < N; i++) {
            Arrays.fill(visit[i], false);
        }

        // BFS íƒìƒ‰ ì‹œì‘
        queue.clear();
        queue.offer(new Node(sy, sx, 0));
        visit[sy][sx] = true;

        while (!queue.isEmpty()) {
            Node node = queue.poll();
            int y = node.y, x = node.x, d = node.d;

            // ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸° ë°œê²¬ ğŸ¯
            if (map[y][x] < sSize && map[y][x] > 0) {
                if (d < minDis || (d == minDis && (y < minY || (y == minY && x < minX)))) {
                    minDis = d;
                    minY = y;
                    minX = x;
                }
            }

            // ì‚¬ë°© íƒìƒ‰
            for (int i = 0; i < 4; i++) {
                int ny = y + dy[i];
                int nx = x + dx[i];

                // ë²”ìœ„ ë°– or ì´ë¯¸ ë°©ë¬¸ or ì§€ë‚˜ê°ˆ ìˆ˜ ì—†ëŠ” ê²½ìš°
                if (ny < 0 || nx < 0 || ny >= N || nx >= N) continue;
                if (visit[ny][nx] || map[ny][nx] > sSize) continue;

                visit[ny][nx] = true;
                queue.offer(new Node(ny, nx, d + 1));
            }
        }

        // ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ê°€ ì—†ëŠ” ê²½ìš°
        if (minDis == Integer.MAX_VALUE) return 0;

        // ë¬¼ê³ ê¸° ë¨¹ê¸° ì²˜ë¦¬ ğŸ½ï¸
        sEatCnt++;
        if (sEatCnt == sSize) {
            sSize++;        // ìƒì–´ í¬ê¸° ì¦ê°€
            sEatCnt = 0;    // ë¨¹ì€ ê°œìˆ˜ ì´ˆê¸°í™”
        }

        // ìƒì–´ ìœ„ì¹˜ ì´ë™ + ë§µ ê°±ì‹ 
        map[sy][sx] = 0;        // ì´ì „ ìœ„ì¹˜ ë¹„ìš°ê¸°
        map[minY][minX] = 0;    // ë¨¹ì€ ìë¦¬ ë¹„ìš°ê¸°
        sy = minY;
        sx = minX;

        return minDis; // ì´ë™ ê±°ë¦¬ ë°˜í™˜
    }

    // BFS íƒìƒ‰ìš© ë…¸ë“œ í´ë˜ìŠ¤ (ìœ„ì¹˜ + ê±°ë¦¬ ì •ë³´)
    static class Node {
        int y, x, d;

        Node(int y, int x, int d) {
            this.y = y;
            this.x = x;
            this.d = d;
        }
    }
}

/*
6
5 4 3 2 3 4
4 3 2 3 4 5
3 2 9 5 6 6
2 1 2 3 4 5
3 2 1 6 5 4
6 6 6 6 6 6

ì¶œë ¥: 60
 */```
